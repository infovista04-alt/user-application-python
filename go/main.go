// user_application_20260213_093948 - Go/Gin API
// Auto-generated by AI Engineer Agent

package main

import (
	"net/http"
	"os"
	"sync"
	"time"

	"github.com/gin-contrib/cors"
	"github.com/gin-gonic/gin"
)

// Models
type Item struct {
	ID          int       `json:"id"`
	Name        string    `json:"name" binding:"required"`
	Description string    `json:"description"`
	Price       float64   `json:"price" binding:"required"`
	IsActive    bool      `json:"is_active"`
	CreatedAt   time.Time `json:"created_at"`
}

type User struct {
	ID        int       `json:"id"`
	Username  string    `json:"username" binding:"required"`
	Email     string    `json:"email" binding:"required,email"`
	IsActive  bool      `json:"is_active"`
	CreatedAt time.Time `json:"created_at"`
}

type HealthResponse struct {
	Status    string `json:"status"`
	Timestamp string `json:"timestamp"`
	Version   string `json:"version"`
}

// In-memory store
var (
	items         []Item
	users         []User
	itemIDCounter int
	userIDCounter int
	mu            sync.RWMutex
)

func main() {
	port := os.Getenv("PORT")
	if port == "" {
		port = "8080"
	}

	r := gin.Default()

	// CORS
	r.Use(cors.Default())

	// Routes
	r.GET("/", healthHandler)
	r.GET("/health", healthHandler)

	api := r.Group("/api")
	{
		api.GET("/items", listItems)
		api.POST("/items", createItem)
		api.GET("/items/:id", getItem)
		api.DELETE("/items/:id", deleteItem)

		api.GET("/users", listUsers)
		api.POST("/users", createUser)
	}

	r.Run(":" + port)
}

func healthHandler(c *gin.Context) {
	c.JSON(http.StatusOK, HealthResponse{
		Status:    "healthy",
		Timestamp: time.Now().UTC().Format(time.RFC3339),
		Version:   "1.0.0",
	})
}

func listItems(c *gin.Context) {
	mu.RLock()
	defer mu.RUnlock()
	c.JSON(http.StatusOK, items)
}

func createItem(c *gin.Context) {
	var item Item
	if err := c.ShouldBindJSON(&item); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	mu.Lock()
	itemIDCounter++
	item.ID = itemIDCounter
	item.CreatedAt = time.Now().UTC()
	items = append(items, item)
	mu.Unlock()

	c.JSON(http.StatusCreated, item)
}

func getItem(c *gin.Context) {
	id := c.Param("id")
	mu.RLock()
	defer mu.RUnlock()

	for _, item := range items {
		if string(rune(item.ID)) == id {
			c.JSON(http.StatusOK, item)
			return
		}
	}
	c.JSON(http.StatusNotFound, gin.H{"error": "Item not found"})
}

func deleteItem(c *gin.Context) {
	id := c.Param("id")
	mu.Lock()
	defer mu.Unlock()

	for i, item := range items {
		if string(rune(item.ID)) == id {
			items = append(items[:i], items[i+1:]...)
			c.Status(http.StatusNoContent)
			return
		}
	}
	c.JSON(http.StatusNotFound, gin.H{"error": "Item not found"})
}

func listUsers(c *gin.Context) {
	mu.RLock()
	defer mu.RUnlock()
	c.JSON(http.StatusOK, users)
}

func createUser(c *gin.Context) {
	var user User
	if err := c.ShouldBindJSON(&user); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	mu.Lock()
	userIDCounter++
	user.ID = userIDCounter
	user.IsActive = true
	user.CreatedAt = time.Now().UTC()
	users = append(users, user)
	mu.Unlock()

	c.JSON(http.StatusCreated, user)
}
